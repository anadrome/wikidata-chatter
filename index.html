<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ambient Wikidata Chatter</title>
    <style>
        body {
            background-color: #1a1a1a;
            color: #e0e0e0;
            font-family: 'Courier New', Courier, monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }
        #container {
            width: 80%;
            max-width: 800px;
            text-align: center;
        }
        #chatter-box {
            font-size: 1.5rem;
            min-height: 200px;
            display: none;
            flex-direction: column;
            justify-content: flex-end;
            margin-bottom: 2rem;
            text-shadow: 0 0 10px rgba(0, 255, 0, 0.2);
        }
        .message {
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 1s ease-out, transform 1s ease-out;
            margin-bottom: 1rem;
            color: #4caf50;
        }
        .message.visible {
            opacity: 1;
            transform: translateY(0);
        }
        .message.old {
            opacity: 0.3;
            color: #888;
        }
        #status {
            font-size: 0.8rem;
            color: #666;
            margin-bottom: 1rem;
            margin-top: 0.5rem;
        }
        input, button {
            background: #333;
            color: #fff;
            border: 1px solid #555;
            padding: 0 15px;
            font-family: inherit;
            box-sizing: border-box;
            height: 42px;
            vertical-align: middle;
        }
        button {
            cursor: pointer;
        }
        button:hover {
            background: #444;
        }
        .meta {
            font-size: 0.6em;
            color: #555;
            margin-top: 0.2rem;
        }
        #controls {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            justify-content: center;
        }
        input {
            width: 250px;
        }
        #btn-geo-fill {
            font-size: 1.2em;
            line-height: 1;
            padding: 0 10px;
        }
        h1 {
            font-size: 2.5rem;
            margin-bottom: 2rem;
            color: #4caf50;
            text-shadow: 0 0 15px rgba(76, 175, 80, 0.4);
            letter-spacing: 2px;
            text-transform: uppercase;
        }
        #setup-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 0.5s ease-in-out;
        }
    </style>
</head>
<body>

<div id="container">
    <div id="chatter-box"></div>
    <div id="setup-screen">
        <h1>Ambient Wikidata Chatter</h1>
        <div id="controls">
            <input type="text" id="coord-input" placeholder="lat, lon (e.g. 51.5, -0.12)">
            <button id="btn-geo-fill" title="Use Current Location">‚åñ</button>
            <button id="btn-start">Start</button>
        </div>
    </div>
    <div id="status">Enter coordinates or use your location</div>
</div>

<script>
    class WikidataFetcher {
        constructor(limit = 100) {
            this.endpoint = "https://query.wikidata.org/sparql";
            this.limit = limit;
            this.languages = "en,mul,de,fr,es,ru,it,pl,zh,ja,pt,nl,sv,da,no,nn,fi,uk,el,tr,cs,sk,sl,ca";
        }

        async fetchNearby(lat, lon, radius = 1) {
            console.log(`Fetching data for ${lat}, ${lon}...`);
            
            const queries = [
                this.getLocationsQuery(lat, lon, radius),
                this.getBuildingsQuery(lat, lon, radius),
                this.getBirthsQuery(lat, lon, radius),
                this.getDeathsQuery(lat, lon, radius),
                this.getEventsQuery(lat, lon, radius),
                this.getHeadquartersQuery(lat, lon, radius),
                this.getFilmingQuery(lat, lon, radius),
                this.getFictionQuery(lat, lon, radius),
                this.getFormationQuery(lat, lon, radius)
            ];

            const results = await Promise.all(queries.map(q => this.runQuery(q)));
            const flatResults = results.flat();

            // Deduplicate by ID (QID)
            const seen = new Set();
            return flatResults.filter(item => {
                if (seen.has(item.id)) return false;
                seen.add(item.id);
                return true;
            });
        }

        async fetchTotalCount(lat, lon, radius) {
            const query = `
                SELECT (COUNT(DISTINCT ?item) AS ?count) WHERE {
                  SERVICE wikibase:around {
                    ?place wdt:P625 ?loc .
                    bd:serviceParam wikibase:center "Point(${lon} ${lat})"^^geo:wktLiteral .
                    bd:serviceParam wikibase:radius "${radius}" .
                  }
                  { BIND(?place AS ?item) }
                  UNION { ?item wdt:P19 ?place }   # Born here
                  UNION { ?item wdt:P20 ?place }   # Died here
                  UNION { ?item wdt:P159 ?place }  # Headquartered here
                  UNION { ?item wdt:P840 ?place }  # Narrative (fiction) location
                  UNION { ?item wdt:P915 ?place }  # Filming location
                  UNION { ?item wdt:P740 ?place }  # Formed here
                }`;

            try {
                const url = this.endpoint + "?query=" + encodeURIComponent(query) + "&format=json";
                const response = await fetch(url);
                if (!response.ok) return null;
                const data = await response.json();
                return parseInt(data.results.bindings[0].count.value);
            } catch (e) {
                console.warn("Total count query failed", e);
                return null;
            }
        }

        async runQuery(query) {
            const url = this.endpoint + "?query=" + encodeURIComponent(query) + "&format=json";
            try {
                const response = await fetch(url);
                if (!response.ok) return [];
                const data = await response.json();
                return this.processResults(data.results.bindings);
            } catch (e) {
                console.error("Query failed", e);
                return [];
            }
        }

        getLocationsQuery(lat, lon, radius) {
            return `
                SELECT DISTINCT ?item ?itemLabel ?itemDescription ?date ("location" AS ?type) ?sitelinks WHERE {
                  SERVICE wikibase:around {
                    ?item wdt:P625 ?loc .
                    bd:serviceParam wikibase:center "Point(${lon} ${lat})"^^geo:wktLiteral .
                    bd:serviceParam wikibase:radius "${radius}" .
                  }
                  OPTIONAL { ?item wikibase:sitelinks ?sitelinks . }
                  OPTIONAL { ?item wdt:P571 ?date }
                  SERVICE wikibase:label { bd:serviceParam wikibase:language "${this.languages}". }
                } ORDER BY DESC(?sitelinks) LIMIT ${this.limit}`;
        }

        getBuildingsQuery(lat, lon, radius) {
            return `
                SELECT DISTINCT ?item ?itemLabel ?itemDescription ("building" AS ?type) ?sitelinks WHERE {
                  SERVICE wikibase:around {
                    ?item wdt:P625 ?loc .
                    bd:serviceParam wikibase:center "Point(${lon} ${lat})"^^geo:wktLiteral .
                    bd:serviceParam wikibase:radius "${radius}" .
                  }
                  VALUES ?buildingTypes {
                    wd:Q33506 wd:Q7075 wd:Q16970 wd:Q24354 wd:Q41253
                    wd:Q23413 wd:Q16917 wd:Q12280 wd:Q55488 wd:Q3918
                    wd:Q483110 wd:Q2977
                  }
                  ?item wdt:P31 ?buildingTypes .

                  OPTIONAL { ?item wikibase:sitelinks ?sitelinks . }
                  SERVICE wikibase:label { bd:serviceParam wikibase:language "${this.languages}". }
                } ORDER BY DESC(?sitelinks) LIMIT ${this.limit}`;
        }

        getBirthsQuery(lat, lon, radius) {
            return `
                SELECT DISTINCT ?item ?itemLabel ?itemDescription ?date ("birth" AS ?type) ?sitelinks WHERE {
                  SERVICE wikibase:around {
                    ?place wdt:P625 ?loc .
                    bd:serviceParam wikibase:center "Point(${lon} ${lat})"^^geo:wktLiteral .
                    bd:serviceParam wikibase:radius "${radius}" .
                  }
                  ?item wdt:P19 ?place .
                  ?item wdt:P569 ?date .
                  OPTIONAL { ?item wikibase:sitelinks ?sitelinks . }
                  SERVICE wikibase:label { bd:serviceParam wikibase:language "${this.languages}". }
                } ORDER BY DESC(?sitelinks) LIMIT ${this.limit}`;
        }

        getDeathsQuery(lat, lon, radius) {
            return `
                SELECT DISTINCT ?item ?itemLabel ?itemDescription ?date ("death" AS ?type) ?sitelinks WHERE {
                  SERVICE wikibase:around {
                    ?place wdt:P625 ?loc .
                    bd:serviceParam wikibase:center "Point(${lon} ${lat})"^^geo:wktLiteral .
                    bd:serviceParam wikibase:radius "${radius}" .
                  }
                  ?item wdt:P20 ?place .
                  ?item wdt:P570 ?date .
                  OPTIONAL { ?item wikibase:sitelinks ?sitelinks . }
                  SERVICE wikibase:label { bd:serviceParam wikibase:language "${this.languages}". }
                } ORDER BY DESC(?sitelinks) LIMIT ${this.limit}`;
        }

        getEventsQuery(lat, lon, radius) {
            return `
                SELECT DISTINCT ?item ?itemLabel ?itemDescription ?date ("event" AS ?type) ?sitelinks WHERE {
                  SERVICE wikibase:around {
                    ?item wdt:P625 ?loc .
                    bd:serviceParam wikibase:center "Point(${lon} ${lat})"^^geo:wktLiteral .
                    bd:serviceParam wikibase:radius "${radius}" .
                  }

                  # Either it has a specific point in time...
                  {
                    ?item wdt:P585 ?date .
                  }
                  UNION
                  # ...OR it has a start time AND is one of these specific event types
                  {
                    ?item wdt:P580 ?date .
                    VALUES ?goodClasses {
                        wd:Q178561 wd:Q198 wd:Q7944 wd:Q168983 wd:Q132241
                        wd:Q868557 wd:Q464980 wd:Q216048 wd:Q1141386 wd:Q17156793
                        wd:Q40231 wd:Q273120 wd:Q2020153 wd:Q182832
                    }
                    ?item wdt:P31 ?goodClasses .
                  }

                  OPTIONAL { ?item wikibase:sitelinks ?sitelinks . }
                  SERVICE wikibase:label { bd:serviceParam wikibase:language "${this.languages}". }
                } ORDER BY DESC(?sitelinks) LIMIT ${this.limit}`;
        }

        getHeadquartersQuery(lat, lon, radius) {
            return `
                SELECT DISTINCT ?item ?itemLabel ?itemDescription ?date ("headquarters" AS ?type) ?sitelinks WHERE {
                  SERVICE wikibase:around {
                    ?place wdt:P625 ?loc .
                    bd:serviceParam wikibase:center "Point(${lon} ${lat})"^^geo:wktLiteral .
                    bd:serviceParam wikibase:radius "${radius}" .
                  }
                  ?item wdt:P159 ?place . # Headquartered here
                  OPTIONAL { ?item wdt:P571 ?date }
                  OPTIONAL { ?item wikibase:sitelinks ?sitelinks . }
                  SERVICE wikibase:label { bd:serviceParam wikibase:language "${this.languages}". }
                } ORDER BY DESC(?sitelinks) LIMIT ${this.limit}`;
        }

        getFilmingQuery(lat, lon, radius) {
            return `
                SELECT DISTINCT ?item ?itemLabel ?itemDescription ?date ("filming" AS ?type) ?sitelinks WHERE {
                  SERVICE wikibase:around {
                    ?place wdt:P625 ?loc .
                    bd:serviceParam wikibase:center "Point(${lon} ${lat})"^^geo:wktLiteral .
                    bd:serviceParam wikibase:radius "${radius}" .
                  }
                  ?item wdt:P915 ?place . # Filming location
                  OPTIONAL { ?item wdt:P577 ?date } # Publication date
                  OPTIONAL { ?item wikibase:sitelinks ?sitelinks . }
                  SERVICE wikibase:label { bd:serviceParam wikibase:language "${this.languages}". }
                } ORDER BY DESC(?sitelinks) LIMIT ${this.limit}`;
        }

        getFictionQuery(lat, lon, radius) {
            return `
                SELECT DISTINCT ?item ?itemLabel ?itemDescription ?date ("fiction" AS ?type) ?sitelinks WHERE {
                  SERVICE wikibase:around {
                    ?place wdt:P625 ?loc .
                    bd:serviceParam wikibase:center "Point(${lon} ${lat})"^^geo:wktLiteral .
                    bd:serviceParam wikibase:radius "${radius}" .
                  }
                  ?item wdt:P840 ?place . # Narrative location
                  OPTIONAL { ?item wdt:P577 ?date } # Publication date
                  OPTIONAL { ?item wikibase:sitelinks ?sitelinks . }
                  SERVICE wikibase:label { bd:serviceParam wikibase:language "${this.languages}". }
                } ORDER BY DESC(?sitelinks) LIMIT ${this.limit}`;
        }

        getFormationQuery(lat, lon, radius) {
            return `
                SELECT DISTINCT ?item ?itemLabel ?itemDescription ?date ("formation" AS ?type) ?sitelinks WHERE {
                  SERVICE wikibase:around {
                    ?place wdt:P625 ?loc .
                    bd:serviceParam wikibase:center "Point(${lon} ${lat})"^^geo:wktLiteral .
                    bd:serviceParam wikibase:radius "${radius}" .
                  }
                  ?item wdt:P740 ?place . # Formed here
                  OPTIONAL { ?item wdt:P571 ?date } # Inception
                  OPTIONAL { ?item wikibase:sitelinks ?sitelinks . }
                  SERVICE wikibase:label { bd:serviceParam wikibase:language "${this.languages}". }
                } ORDER BY DESC(?sitelinks) LIMIT ${this.limit}`;
        }

        processResults(bindings) {
            return bindings.map(b => ({
                id: b.item.value, // Capture QID for deduplication
                label: b.itemLabel.value,
                desc: b.itemDescription ? b.itemDescription.value : "",
                date: b.date ? this.formatDate(b.date.value) : null,
                type: b.type.value,
                sitelinks: b.sitelinks ? parseInt(b.sitelinks.value) : 0
            }));
        }

        formatDate(dateStr) {
            const year = parseInt(dateStr);
            if (isNaN(year)) return null;
            return year > 0 ? year.toString() : (1 - year) + " BCE";
        }
    }

    class AmbientChatter {
        constructor() {
            this.fetcher = new WikidataFetcher();
            this.facts = [];
            this.deck = []; // A shuffled deck of facts to read from
            this.displayEl = document.getElementById('chatter-box');
            this.statusEl = document.getElementById('status');
            this.inputEl = document.getElementById('coord-input');
            this.isRambling = false;

            this.init();
        }

        init() {
            document.getElementById('btn-start').addEventListener('click', () => {
                this.parseAndStart(this.inputEl.value);
            });

            document.getElementById('btn-geo-fill').addEventListener('click', () => {
                if ("geolocation" in navigator) {
                    this.statusEl.innerText = "Locating you...";
                    navigator.geolocation.getCurrentPosition((position) => {
                        const lat = position.coords.latitude.toFixed(5);
                        const lon = position.coords.longitude.toFixed(5);
                        this.inputEl.value = `${lat}, ${lon}`;
                        this.statusEl.innerText = "Coordinates found. Click Start.";
                    }, (err) => {
                        this.statusEl.innerText = "Could not get location: " + err.message;
                    });
                } else {
                    this.statusEl.innerText = "Geolocation not supported.";
                }
            });

            // Allow "Enter" key in input
            this.inputEl.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') this.parseAndStart(this.inputEl.value);
            });
        }

        parseAndStart(coordsStr) {
            if (!coordsStr) {
                this.statusEl.innerText = "Please enter coordinates.";
                return;
            }
            const parts = coordsStr.split(',').map(p => p.trim());
            if (parts.length !== 2) {
                this.statusEl.innerText = "Invalid format. Use 'lat, lon'.";
                return;
            }
            const lat = parseFloat(parts[0]);
            const lon = parseFloat(parts[1]);

            if (isNaN(lat) || isNaN(lon)) {
                this.statusEl.innerText = "Invalid coordinates.";
                return;
            }
            this.start(lat, lon);
        }

        async start(lat, lon) {
            document.getElementById('setup-screen').style.display = 'none';
            this.displayEl.style.display = 'flex';
            const radii = [1, 5, 20, 50]; // Scan range in km

            for (const radius of radii) {
                this.statusEl.innerText = `Scanning wikidata around ${lat.toFixed(4)}, ${lon.toFixed(4)} (${radius}km radius)...`;
                
                try {
                    const [newFacts, totalCount] = await Promise.all([
                        this.fetcher.fetchNearby(lat, lon, radius),
                        this.fetcher.fetchTotalCount(lat, lon, radius)
                    ]);
                    
                    // If we found enough facts, or this is our last attempt, start rambling
                    if (newFacts.length > 20 || radius === 50) {
                         this.facts = newFacts;

                         let msg = `Found ${this.facts.length} items within ${radius}km.`;
                         if (totalCount !== null && totalCount > this.facts.length) {
                             msg = `Found ${totalCount} items within ${radius}km. Selected ${this.facts.length}.`;
                         }

                         this.statusEl.innerText = msg;
                         
                         if (this.facts.length === 0) {
                             this.speak({ label: "I don't see anything near here.", type: 'none' });
                             return;
                         }

                         if (!this.isRambling) {
                             this.isRambling = true;
                             this.rambleLoop();
                         }
                         return;
                    }
                } catch (e) {
                    this.statusEl.innerText = "Error connecting to Wikidata.";
                    return;
                }
            }
        }

        rambleLoop() {
            if (this.facts.length === 0) return;

            // Refill deck if empty
            if (this.deck.length === 0) {
                this.deck = [...this.facts];
                this.shuffle(this.deck);
                // prevent the last item of the old deck from being the first of the new one
                if (this.deck.length > 1 && this.lastFact && this.deck[0].id === this.lastFact.id) {
                    this.deck.push(this.deck.shift());
                }
            }

            // Random fact
            const fact = this.deck.pop();
            this.lastFact = fact;
            this.speak(fact);
            
            // Schedule next fact (random interval between 4s and 8s)
            setTimeout(() => this.rambleLoop(), 4000 + Math.random() * 4000);
        }

        shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        speak(fact) {
            const sentence = this.constructSentence(fact);
            
            const msg = document.createElement('div');
            msg.className = 'message';
            msg.innerHTML = `
                ${sentence}
                ${fact.type !== 'none' ? `<div class="meta">(${fact.type} / ${fact.sitelinks} refs)</div>` : ''}
            `;
            
            this.displayEl.appendChild(msg);
            
            // Trigger animation
            setTimeout(() => msg.classList.add('visible'), 50);

            // Fade out old messages
            const messages = this.displayEl.querySelectorAll('.message');
            if (messages.length > 3) {
                messages[0].classList.add('old');
                if (messages.length > 5) {
                    messages[0].remove();
                }
            }
        }

        constructSentence(fact) {
            if (fact.type === 'none') return fact.label;
            const templates = {
                'birth': [
                    `${fact.label} entered the world near here in ${fact.date}`,
                    `In ${fact.date}, ${fact.label} was born close by`,
                    `The story of ${fact.label} began here in ${fact.date}`
                ],
                'death': [
                    `${fact.label} died near this spot in ${fact.date}`,
                    `It was here, in ${fact.date}, that ${fact.label} passed away`,
                    `The journey of ${fact.label} ended here in ${fact.date}`
                ],
                'location': [
                    `You are near ${fact.label}`,
                    `${fact.label} stands nearby`,
                    `Looking around, you might find ${fact.label}`
                ],
                'building': [
                    `${fact.label} stands here`,
                    `You are standing near ${fact.label}`,
                    `This is the site of ${fact.label}`
                ],
                'event': [
                    `In ${fact.date}, ${fact.label} happened right here`,
                    `${fact.label} took place nearby in ${fact.date}`,
                    `This location witnessed ${fact.label} in ${fact.date}`
                ],
                'headquarters': [
                    `${fact.label} is headquartered nearby`,
                    `The headquarters of ${fact.label} can be found here`,
                    `${fact.label} operates from this area`
                ],
                'filming': [
                    `Scenes from ${fact.label} were filmed near here`,
                    `${fact.label} used this location as a backdrop`,
                    `A film crew for ${fact.label} was once here`
                ],
                'fiction': [
                    `The story of ${fact.label} is set in this area`,
                    `This location features in the plot of ${fact.label}`,
                    `${fact.label} takes place nearby`
                ],
                'formation': fact.date ? [
                    `${fact.label} was formed nearby in ${fact.date}`,
                    `The group ${fact.label} started their journey near here`,
                    `In ${fact.date}, ${fact.label} was founded close by`
                ] : [
                    `${fact.label} was formed nearby`,
                    `The group ${fact.label} started their journey near here`,
                    `${fact.label} was founded close by`
                ]
            };

            // Generic fallback
            if (!templates[fact.type]) {
                return `${fact.label} is nearby`;
            }

            const options = templates[fact.type];
            let text = options[Math.floor(Math.random() * options.length)];
            
            // Append description sometimes
            if (Math.random() > 0.5 && fact.desc) {
                text += ` (${fact.desc})`;
            }
            text += ".";
            
            return text;
        }
    }

    new AmbientChatter();
</script>

</body>
</html>
