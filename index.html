<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Local Traces</title>
    <style>
        body {
            background-color: #1a1a1a;
            color: #e0e0e0;
            font-family: 'Courier New', Courier, monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }
        #container {
            width: 80%;
            max-width: 800px;
            min-width: 320px;
            text-align: center;
        }
        #chatter-box {
            font-size: 1.5rem;
            min-height: 200px;
            display: none;
            flex-direction: column;
            justify-content: flex-end;
            margin-bottom: 2rem;
            text-shadow: 0 0 10px rgba(0, 255, 0, 0.2);
        }
        .message {
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 1s ease-out, transform 1s ease-out;
            margin-bottom: 1rem;
            color: #4caf50;
            word-wrap: break-word;
        }
        .message.visible {
            opacity: 1;
            transform: translateY(0);
        }
        .message a {
            color: inherit;
            text-decoration: underline;
            text-decoration-style: dotted;
            text-decoration-thickness: 1px;
            text-underline-offset: 5px;
        }
        .message a:hover {
            color: #81c784;
            text-decoration-style: solid;
        }
        .message.old {
            opacity: 0.3;
            color: #888;
        }
        #status {
            font-size: 0.8rem;
            color: #666;
            margin-bottom: 1rem;
            margin-top: 0.5rem;
        }
        input, button {
            background: #333;
            color: #fff;
            border: 1px solid #555;
            padding: 0 15px;
            font-family: inherit;
            box-sizing: border-box;
            height: 42px;
        }
        button {
            cursor: pointer;
        }
        button:hover {
            background: #444;
        }
        .meta {
            font-size: 0.6em;
            color: #555;
            margin-top: 0.2rem;
        }
        #controls {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            justify-content: center;
        }
        input {
            width: 250px;
        }
        #btn-geo-fill {
            font-size: 1.2em;
            line-height: 1;
            padding: 0 10px;
        }
        h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
            color: #4caf50;
            text-shadow: 0 0 15px rgba(76, 175, 80, 0.4);
            letter-spacing: 2px;
            text-transform: uppercase;
        }
        #footer {
            position: fixed;
            bottom: 20px;
            font-size: 0.8rem;
            color: #444;
        }
        #footer a {
            color: inherit;
            text-decoration: none;
        }
        #footer a:hover {
            text-decoration: underline;
        }
        #setup-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 0.5s ease-in-out;
        }
    </style>
</head>
<body>

<div id="container">
    <div id="chatter-box"></div>
    <div id="setup-screen">
        <h1>Local Traces</h1>
        <div id="controls">
            <input type="text" id="coord-input" placeholder="lat, lon (e.g. 51.5, -0.12)">
            <button id="btn-geo-fill" title="Use Current Location">‚åñ</button>
            <button id="btn-start">Start</button>
        </div>
    </div>
    <div id="status">Enter coordinates or use your location</div>
</div>

<div id="footer">Powered by <a href="https://www.wikidata.org/" target="_blank">Wikidata</a></div>

<script>
    class WikidataFetcher {
        constructor(limit = 100) {
            this.endpoint = "https://query.wikidata.org/sparql";
            this.limit = limit;
            // start with top-10 Wikipedias; repairLabels() does fallback if needed
            this.languages = "en,mul,de,fr,es,ru,it,pl,zh,ja,pt";
        }

        async fetchNearby(lat, lon, radius = 1) {
            console.log(`Fetching data for ${lat}, ${lon}...`);

            const queries = [
                this.getLocationsQuery(lat, lon, radius),
                this.getBuildingsQuery(lat, lon, radius),
                this.getBirthsQuery(lat, lon, radius),
                this.getDeathsQuery(lat, lon, radius),
                this.getEventsQuery(lat, lon, radius),
                this.getHeadquartersQuery(lat, lon, radius),
                this.getFilmingQuery(lat, lon, radius),
                this.getFictionQuery(lat, lon, radius),
                this.getFormationQuery(lat, lon, radius)
            ];

            const results = await Promise.all(queries.map(q => this.runQuery(q)));
            const flatResults = results.flat();

            // Deduplicate by ID (QID)
            const seen = new Set();
            const uniqueItems = flatResults.filter(item => {
                if (seen.has(item.id)) return false;
                seen.add(item.id);
                return true;
            });

            await this.repairLabels(uniqueItems);
            return uniqueItems;
        }

        async repairLabels(items) {
            // items that look like Qxxx had no label in our language list
            const needsRepair = items.filter(i => /^Q\d+$/.test(i.label));
            if (needsRepair.length === 0) return;

            const chunkArray = (arr, size) => {
                const res = [];
                for (let i = 0; i < arr.length; i += size) res.push(arr.slice(i, i + size));
                return res;
            };

            // chunk to avoid SPARQL query limits (VALUES clause)
            for (const chunk of chunkArray(needsRepair, 50)) {
                const values = chunk.map(i => `<${i.id}>`).join(' ');
                // fetch ANY label for these items
                const query = `SELECT ?item (SAMPLE(?l) AS ?label) WHERE { VALUES ?item { ${values} } ?item rdfs:label ?l } GROUP BY ?item`;

                try {
                    const url = this.endpoint + "?query=" + encodeURIComponent(query) + "&format=json";
                    const response = await fetch(url);
                    if (!response.ok) continue;
                    const data = await response.json();

                    const labelMap = new Map();
                    data.results.bindings.forEach(b => labelMap.set(b.item.value, b.label.value));

                    chunk.forEach(i => {
                        if (labelMap.has(i.id)) {
                            i.label = labelMap.get(i.id);
                        }
                    });
                } catch (e) {
                    // fall back to Qxxx label on error
                }
            }
        }

        async fetchTotalCount(lat, lon, radius) {
            const query = `
                SELECT (COUNT(DISTINCT ?item) AS ?count) WHERE {
                  SERVICE wikibase:around {
                    ?place wdt:P625 ?loc .
                    bd:serviceParam wikibase:center "Point(${lon} ${lat})"^^geo:wktLiteral .
                    bd:serviceParam wikibase:radius "${radius}" .
                  }
                  { BIND(?place AS ?item) }
                  UNION { ?item wdt:P19 ?place }   # Born here
                  UNION { ?item wdt:P20 ?place }   # Died here
                  UNION { ?item wdt:P159 ?place }  # Headquartered here
                  UNION { ?item wdt:P840 ?place }  # Narrative (fiction) location
                  UNION { ?item wdt:P915 ?place }  # Filming location
                  UNION { ?item wdt:P740 ?place }  # Formed here
                }`;

            try {
                const url = this.endpoint + "?query=" + encodeURIComponent(query) + "&format=json";
                const response = await fetch(url);
                if (!response.ok) return null;
                const data = await response.json();
                return parseInt(data.results.bindings[0].count.value);
            } catch (e) {
                console.warn("Total count query failed", e);
                return null;
            }
        }

        async runQuery(query) {
            const url = this.endpoint + "?query=" + encodeURIComponent(query) + "&format=json";
            try {
                const response = await fetch(url);
                if (!response.ok) return [];
                const data = await response.json();
                return this.processResults(data.results.bindings);
            } catch (e) {
                console.error("Query failed", e);
                return [];
            }
        }

        getLocationsQuery(lat, lon, radius) {
            return `
                SELECT DISTINCT ?item ?itemLabel ?enDescription ?dissolved ?dissolvedPrec ?endTime ?endTimePrec ?closed ?closedPrec ("location" AS ?type) ?sitelinks ?instanceLabel WHERE {
                  SERVICE wikibase:around {
                    ?item wdt:P625 ?loc .
                    bd:serviceParam wikibase:center "Point(${lon} ${lat})"^^geo:wktLiteral .
                    bd:serviceParam wikibase:radius "${radius}" .
                  }
                  OPTIONAL { ?item wdt:P31 ?instance . }
                  OPTIONAL { ?item wikibase:sitelinks ?sitelinks . }
                  OPTIONAL {
                    ?item p:P576 ?stmtDissolved .
                    ?stmtDissolved psv:P576 [ wikibase:timeValue ?dissolved; wikibase:timePrecision ?dissolvedPrec ] .
                    ?stmtDissolved rdf:type wikibase:BestRank .
                  }
                  OPTIONAL {
                    ?item p:P582 ?stmtEnd .
                    ?stmtEnd psv:P582 [ wikibase:timeValue ?endTime; wikibase:timePrecision ?endTimePrec ] .
                    ?stmtEnd rdf:type wikibase:BestRank .
                  }
                  OPTIONAL {
                    ?item p:P3999 ?stmtClosed .
                    ?stmtClosed psv:P3999 [ wikibase:timeValue ?closed; wikibase:timePrecision ?closedPrec ] .
                    ?stmtClosed rdf:type wikibase:BestRank .
                  }
                  OPTIONAL { ?item schema:description ?enDescription . FILTER(LANG(?enDescription) = "en") }
                  SERVICE wikibase:label { bd:serviceParam wikibase:language "${this.languages}". }
                } ORDER BY DESC(?sitelinks) LIMIT ${this.limit}`;
        }

        getBuildingsQuery(lat, lon, radius) {
            return `
                SELECT DISTINCT ?item ?itemLabel ?enDescription ?dissolved ?dissolvedPrec ?endTime ?endTimePrec ?closed ?closedPrec ("building" AS ?type) ?sitelinks ?buildingTypesLabel WHERE {
                  SERVICE wikibase:around {
                    ?item wdt:P625 ?loc .
                    bd:serviceParam wikibase:center "Point(${lon} ${lat})"^^geo:wktLiteral .
                    bd:serviceParam wikibase:radius "${radius}" .
                  }
                  VALUES ?buildingTypes {
                    wd:Q33506 wd:Q7075 wd:Q16970 wd:Q24354 wd:Q41253
                    wd:Q23413 wd:Q16917 wd:Q12280 wd:Q55488 wd:Q3918
                    wd:Q483110 wd:Q2977
                  }
                  ?item wdt:P31 ?buildingTypes .

                  OPTIONAL { ?item wikibase:sitelinks ?sitelinks . }
                  OPTIONAL {
                    ?item p:P576 ?stmtDissolved .
                    ?stmtDissolved psv:P576 [ wikibase:timeValue ?dissolved; wikibase:timePrecision ?dissolvedPrec ] .
                    ?stmtDissolved rdf:type wikibase:BestRank .
                  }
                  OPTIONAL {
                    ?item p:P582 ?stmtEnd .
                    ?stmtEnd psv:P582 [ wikibase:timeValue ?endTime; wikibase:timePrecision ?endTimePrec ] .
                    ?stmtEnd rdf:type wikibase:BestRank .
                  }
                  OPTIONAL {
                    ?item p:P3999 ?stmtClosed .
                    ?stmtClosed psv:P3999 [ wikibase:timeValue ?closed; wikibase:timePrecision ?closedPrec ] .
                    ?stmtClosed rdf:type wikibase:BestRank .
                  }
                  OPTIONAL { ?item schema:description ?enDescription . FILTER(LANG(?enDescription) = "en") }
                  SERVICE wikibase:label { bd:serviceParam wikibase:language "${this.languages}". }
                } ORDER BY DESC(?sitelinks) LIMIT ${this.limit}`;
        }

        getBirthsQuery(lat, lon, radius) {
            return `
                SELECT DISTINCT ?item ?itemLabel ?enDescription ?date ?precision ("birth" AS ?type) ?sitelinks ?placeLabel WHERE {
                  SERVICE wikibase:around {
                    ?place wdt:P625 ?loc .
                    bd:serviceParam wikibase:center "Point(${lon} ${lat})"^^geo:wktLiteral .
                    bd:serviceParam wikibase:radius "${radius}" .
                  }
                  ?item wdt:P19 ?place .
                  ?item p:P569 ?stmt .
                  ?stmt psv:P569 [ wikibase:timeValue ?date; wikibase:timePrecision ?precision ] .
                  ?stmt rdf:type wikibase:BestRank .
                  OPTIONAL { ?item wikibase:sitelinks ?sitelinks . }
                  OPTIONAL { ?item schema:description ?enDescription . FILTER(LANG(?enDescription) = "en") }
                  SERVICE wikibase:label { bd:serviceParam wikibase:language "${this.languages}". }
                } ORDER BY DESC(?sitelinks) LIMIT ${this.limit}`;
        }

        getDeathsQuery(lat, lon, radius) {
            return `
                SELECT DISTINCT ?item ?itemLabel ?enDescription ?date ?precision ("death" AS ?type) ?sitelinks ?placeLabel WHERE {
                  SERVICE wikibase:around {
                    ?place wdt:P625 ?loc .
                    bd:serviceParam wikibase:center "Point(${lon} ${lat})"^^geo:wktLiteral .
                    bd:serviceParam wikibase:radius "${radius}" .
                  }
                  ?item wdt:P20 ?place .
                  ?item p:P570 ?stmt .
                  ?stmt psv:P570 [ wikibase:timeValue ?date; wikibase:timePrecision ?precision ] .
                  ?stmt rdf:type wikibase:BestRank .
                  OPTIONAL { ?item wikibase:sitelinks ?sitelinks . }
                  OPTIONAL { ?item schema:description ?enDescription . FILTER(LANG(?enDescription) = "en") }
                  SERVICE wikibase:label { bd:serviceParam wikibase:language "${this.languages}". }
                } ORDER BY DESC(?sitelinks) LIMIT ${this.limit}`;
        }

        getEventsQuery(lat, lon, radius) {
            return `
                SELECT DISTINCT ?item ?itemLabel ?enDescription ?date ?precision ("event" AS ?type) ?sitelinks ?instanceLabel WHERE {
                  SERVICE wikibase:around {
                    ?item wdt:P625 ?loc .
                    bd:serviceParam wikibase:center "Point(${lon} ${lat})"^^geo:wktLiteral .
                    bd:serviceParam wikibase:radius "${radius}" .
                  }

                  # Either it has a specific point in time...
                  {
                    ?item p:P585 ?stmt .
                    ?stmt psv:P585 [ wikibase:timeValue ?date; wikibase:timePrecision ?precision ] .
                    ?stmt rdf:type wikibase:BestRank .
                  }
                  UNION
                  # ...OR it has a start time AND is one of these specific event types
                  {
                    ?item p:P580 ?stmt .
                    ?stmt psv:P580 [ wikibase:timeValue ?date; wikibase:timePrecision ?precision ] .
                    ?stmt rdf:type wikibase:BestRank .
                    VALUES ?goodClasses {
                        wd:Q178561 wd:Q198 wd:Q7944 wd:Q168983 wd:Q132241
                        wd:Q868557 wd:Q464980 wd:Q216048 wd:Q1141386 wd:Q17156793
                        wd:Q40231 wd:Q273120 wd:Q2020153 wd:Q182832
                    }
                    ?item wdt:P31 ?goodClasses .
                  }

                  OPTIONAL { ?item wikibase:sitelinks ?sitelinks . }
                  OPTIONAL { ?item wdt:P31 ?instance . }
                  OPTIONAL { ?item schema:description ?enDescription . FILTER(LANG(?enDescription) = "en") }
                  SERVICE wikibase:label { bd:serviceParam wikibase:language "${this.languages}". }
                } ORDER BY DESC(?sitelinks) LIMIT ${this.limit}`;
        }

        getHeadquartersQuery(lat, lon, radius) {
            return `
                SELECT DISTINCT ?item ?itemLabel ?enDescription ?dissolved ?dissolvedPrec ?endTime ?endTimePrec ?closed ?closedPrec ("headquarters" AS ?type) ?sitelinks ?instanceLabel WHERE {
                  {
                    SERVICE wikibase:around {
                      ?place wdt:P625 ?loc .
                      bd:serviceParam wikibase:center "Point(${lon} ${lat})"^^geo:wktLiteral .
                      bd:serviceParam wikibase:radius "${radius}" .
                    }
                    ?item wdt:P159 ?place . # Headquartered here (standard city/place)
                  }
                  UNION
                  {
                    SERVICE wikibase:around {
                      ?stmt pq:P625 ?loc .
                      bd:serviceParam wikibase:center "Point(${lon} ${lat})"^^geo:wktLiteral .
                      bd:serviceParam wikibase:radius "${radius}" .
                    }
                    ?item p:P159 ?stmt . # Headquartered here (specific qualifier coord)
                  }
                  OPTIONAL {
                    ?item p:P576 ?stmtDissolved .
                    ?stmtDissolved psv:P576 [ wikibase:timeValue ?dissolved; wikibase:timePrecision ?dissolvedPrec ] .
                    ?stmtDissolved rdf:type wikibase:BestRank .
                  }
                  OPTIONAL {
                    ?item p:P582 ?stmtEnd .
                    ?stmtEnd psv:P582 [ wikibase:timeValue ?endTime; wikibase:timePrecision ?endTimePrec ] .
                    ?stmtEnd rdf:type wikibase:BestRank .
                  }
                  OPTIONAL {
                    ?item p:P3999 ?stmtClosed .
                    ?stmtClosed psv:P3999 [ wikibase:timeValue ?closed; wikibase:timePrecision ?closedPrec ] .
                    ?stmtClosed rdf:type wikibase:BestRank .
                  }
                  OPTIONAL { ?item wikibase:sitelinks ?sitelinks . }
                  OPTIONAL { ?item wdt:P31 ?instance . }
                  OPTIONAL { ?item schema:description ?enDescription . FILTER(LANG(?enDescription) = "en") }
                  SERVICE wikibase:label { bd:serviceParam wikibase:language "${this.languages}". }
                } ORDER BY DESC(?sitelinks) LIMIT ${this.limit}`;
        }

        getFilmingQuery(lat, lon, radius) {
            return `
                SELECT DISTINCT ?item ?itemLabel ?enDescription ("filming" AS ?type) ?sitelinks ?instanceLabel WHERE {
                  SERVICE wikibase:around {
                    ?place wdt:P625 ?loc .
                    bd:serviceParam wikibase:center "Point(${lon} ${lat})"^^geo:wktLiteral .
                    bd:serviceParam wikibase:radius "${radius}" .
                  }
                  ?item wdt:P915 ?place . # Filming location
                  OPTIONAL { ?item wikibase:sitelinks ?sitelinks . }
                  OPTIONAL { ?item wdt:P31 ?instance . }
                  OPTIONAL { ?item schema:description ?enDescription . FILTER(LANG(?enDescription) = "en") }
                  SERVICE wikibase:label { bd:serviceParam wikibase:language "${this.languages}". }
                } ORDER BY DESC(?sitelinks) LIMIT ${this.limit}`;
        }

        getFictionQuery(lat, lon, radius) {
            return `
                SELECT DISTINCT ?item ?itemLabel ?enDescription ("fiction" AS ?type) ?sitelinks ?instanceLabel WHERE {
                  SERVICE wikibase:around {
                    ?place wdt:P625 ?loc .
                    bd:serviceParam wikibase:center "Point(${lon} ${lat})"^^geo:wktLiteral .
                    bd:serviceParam wikibase:radius "${radius}" .
                  }
                  ?item wdt:P840 ?place . # Narrative location
                  OPTIONAL { ?item wikibase:sitelinks ?sitelinks . }
                  OPTIONAL { ?item wdt:P31 ?instance . }
                  OPTIONAL { ?item schema:description ?enDescription . FILTER(LANG(?enDescription) = "en") }
                  SERVICE wikibase:label { bd:serviceParam wikibase:language "${this.languages}". }
                } ORDER BY DESC(?sitelinks) LIMIT ${this.limit}`;
        }

        getFormationQuery(lat, lon, radius) {
            return `
                SELECT DISTINCT ?item ?itemLabel ?enDescription ?date ?precision ("formation" AS ?type) ?sitelinks ?instanceLabel WHERE {
                  SERVICE wikibase:around {
                    ?place wdt:P625 ?loc .
                    bd:serviceParam wikibase:center "Point(${lon} ${lat})"^^geo:wktLiteral .
                    bd:serviceParam wikibase:radius "${radius}" .
                  }
                  ?item wdt:P740 ?place . # Formed here
                  OPTIONAL {
                    ?item p:P571 ?stmt .
                    ?stmt psv:P571 [ wikibase:timeValue ?date; wikibase:timePrecision ?precision ] .
                    ?stmt rdf:type wikibase:BestRank .
                  } # Inception
                  OPTIONAL { ?item wikibase:sitelinks ?sitelinks . }
                  OPTIONAL { ?item wdt:P31 ?instance . }
                  OPTIONAL { ?item schema:description ?enDescription . FILTER(LANG(?enDescription) = "en") }
                  SERVICE wikibase:label { bd:serviceParam wikibase:language "${this.languages}". }
                } ORDER BY DESC(?sitelinks) LIMIT ${this.limit}`;
        }

        processResults(bindings) {
            return bindings.map(b => {
                let end = null;
                let endPrec = null;

                if (b.dissolved) {
                    end = b.dissolved;
                    endPrec = b.dissolvedPrec;
                } else if (b.endTime) {
                    end = b.endTime;
                    endPrec = b.endTimePrec;
                } else if (b.closed) {
                    end = b.closed;
                    endPrec = b.closedPrec;
                }

                let subtype = null;
                if (b.placeLabel) subtype = b.placeLabel.value;
                else if (b.buildingTypesLabel) subtype = b.buildingTypesLabel.value;
                else if (b.instanceLabel) subtype = b.instanceLabel.value;

                return {
                    id: b.item.value, // Capture QID for deduplication
                    label: b.itemLabel.value,
                    desc: b.enDescription ? b.enDescription.value : "",
                    date: b.date ? this.formatDate(b.date.value, b.precision ? b.precision.value : null) : null,
                    type: b.type.value,
                    sitelinks: b.sitelinks ? parseInt(b.sitelinks.value) : 0,
                    ended: end ? this.formatDate(end.value, endPrec ? endPrec.value : null) : null,
                    subtype: subtype
                };
            });
        }

        formatDate(dateStr, precisionStr) {
            const year = parseInt(dateStr);
            if (isNaN(year)) return null;

            const precision = precisionStr ? parseInt(precisionStr) : 9;

            if (precision === 7) { // century
                const absYear = Math.abs(year);
                const century = year > 0 ? Math.floor(absYear / 100) + 1 : Math.ceil(absYear / 100);
                const era = year > 0 ? "" : " BCE";

                // Ordinal suffix
                const j = century % 10,
                      k = century % 100;
                let ordinal = "th";
                if (j == 1 && k != 11) {
                    ordinal = "st";
                }
                if (j == 2 && k != 12) {
                    ordinal = "nd";
                }
                if (j == 3 && k != 13) {
                    ordinal = "rd";
                }

                return `the ${century}${ordinal} century${era}`;
            }

            if (precision === 8) { // decade
                const decade = Math.floor(Math.abs(year) / 10) * 10;
                const era = year > 0 ? "" : " BCE";
                return `the ${decade}s${era}`;
            }

            // treat any other precision as year
            return year > 0 ? year.toString() : (1 - year) + " BCE";
        }
    }

    class AmbientChatter {
        constructor() {
            this.fetcher = new WikidataFetcher();
            this.facts = [];
            this.deck = []; // A shuffled deck of facts to read from
            this.displayEl = document.getElementById('chatter-box');
            this.statusEl = document.getElementById('status');
            this.inputEl = document.getElementById('coord-input');
            this.isRambling = false;

            this.init();
        }

        init() {
            document.getElementById('btn-start').addEventListener('click', () => {
                this.parseAndStart(this.inputEl.value);
            });

            document.getElementById('btn-geo-fill').addEventListener('click', () => {
                if ("geolocation" in navigator) {
                    this.statusEl.innerText = "Locating you...";
                    navigator.geolocation.getCurrentPosition((position) => {
                        const lat = position.coords.latitude.toFixed(5);
                        const lon = position.coords.longitude.toFixed(5);
                        this.inputEl.value = `${lat}, ${lon}`;
                        this.statusEl.innerText = "Coordinates found. Click Start.";
                    }, (err) => {
                        this.statusEl.innerText = "Could not get location: " + err.message;
                    });
                } else {
                    this.statusEl.innerText = "Geolocation not supported.";
                }
            });

            // Allow "Enter" key in input
            this.inputEl.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') this.parseAndStart(this.inputEl.value);
            });
        }

        parseAndStart(coordsStr) {
            if (!coordsStr) {
                this.statusEl.innerText = "Please enter coordinates.";
                return;
            }
            const parts = coordsStr.split(',').map(p => p.trim());
            if (parts.length !== 2) {
                this.statusEl.innerText = "Invalid format. Use 'lat, lon'.";
                return;
            }
            const lat = parseFloat(parts[0]);
            const lon = parseFloat(parts[1]);

            if (isNaN(lat) || isNaN(lon)) {
                this.statusEl.innerText = "Invalid coordinates.";
                return;
            }
            this.start(lat, lon);
        }

        async start(lat, lon) {
            document.getElementById('setup-screen').style.display = 'none';
            this.displayEl.style.display = 'flex';
            const radii = [1, 2, 5, 10, 20, 50]; // Scan range in km

            for (const radius of radii) {
                this.statusEl.innerText = `Scanning wikidata around ${lat.toFixed(4)}, ${lon.toFixed(4)} (${radius}km radius)...`;

                try {
                    const [newFacts, totalCount] = await Promise.all([
                        this.fetcher.fetchNearby(lat, lon, radius),
                        this.fetcher.fetchTotalCount(lat, lon, radius)
                    ]);

                    // If we found enough facts, or this is our last attempt, start rambling
                    if (newFacts.length >= 50 || radius === 50) {
                         this.facts = newFacts;

                         let msg = `Found ${this.facts.length} items within ${radius}km.`;
                         if (totalCount !== null && totalCount > this.facts.length) {
                             msg = `Found ${totalCount} items within ${radius}km. Selected ${this.facts.length}.`;
                         }

                         this.statusEl.innerText = msg;

                         if (this.facts.length === 0) {
                             this.speak({ label: "Seems like there's not much nearby.", type: 'none' });
                             return;
                         }

                         if (!this.isRambling) {
                             this.isRambling = true;
                             this.rambleLoop();
                         }
                         return;
                    }
                } catch (e) {
                    this.statusEl.innerText = "Error connecting to Wikidata.";
                    return;
                }
            }
        }

        rambleLoop() {
            if (this.facts.length === 0) return;

            // Refill deck if empty
            if (this.deck.length === 0) {
                this.deck = [...this.facts];
                this.shuffle(this.deck);
                // prevent the last item of the old deck from being the first of the new one
                if (this.deck.length > 1 && this.lastFact && this.deck[0].id === this.lastFact.id) {
                    this.deck.push(this.deck.shift());
                }
            }

            // Random fact
            const fact = this.deck.pop();
            this.lastFact = fact;
            this.speak(fact);

            // Schedule next fact (random interval between 4s and 8s)
            setTimeout(() => this.rambleLoop(), 4000 + Math.random() * 4000);
        }

        shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        speak(fact) {
            // Create a version of the label that is a link
            const linkedFact = { ...fact };
            if (fact.type !== 'none') {
                linkedFact.label = `<a href="${fact.id}" target="_blank">${fact.label}</a>`;
            }

            const sentence = this.constructSentence(linkedFact);

            // Combine type and subtype for meta display
            let metaInfo = fact.type;
            if (fact.subtype && fact.subtype.toLowerCase() !== fact.type.toLowerCase()) {
                metaInfo += ` / ${fact.subtype}`;
            }

            const msg = document.createElement('div');
            msg.className = 'message';
            msg.innerHTML = `
                ${sentence}
                ${fact.type !== 'none' ? `<div class="meta">(${metaInfo})</div>` : ''}
            `;

            this.displayEl.appendChild(msg);

            // Trigger animation
            setTimeout(() => msg.classList.add('visible'), 50);

            // Manage old messages
            const messages = this.displayEl.querySelectorAll('.message');

            if (messages.length > 4) {
                messages[0].remove();
                messages[1].classList.add('old');
            } else if (messages.length === 4) {
                messages[0].classList.add('old');
            }
        }

        constructSentence(fact) {
            if (fact.type === 'none') return fact.label;
            const templates = {
                'birth': [
                    `${fact.label} entered the world near here in ${fact.date}`,
                    `In ${fact.date}, ${fact.label} was born close by`,
                    `The story of ${fact.label} began here in ${fact.date}`
                ],
                'death': [
                    `${fact.label} died near this spot in ${fact.date}`,
                    `It was here, in ${fact.date}, that ${fact.label} passed away`,
                    `The journey of ${fact.label} ended here in ${fact.date}`
                ],
                'location': fact.ended ? [
                    `You are near the former location of ${fact.label}`,
                    `Until ${fact.ended}, ${fact.label} was nearby`,
                    `Looking around, you might have once found ${fact.label}`
                ] : [
                    `You are near ${fact.label}`,
                    `${fact.label} is nearby`,
                    `Looking around, you might find ${fact.label}`
                ],
                'building': fact.ended ? [
                    `${fact.label} stood here until ${fact.ended}`,
                    `Before ${fact.ended}, ${fact.label} was near here`,
                    `This was the former site of ${fact.label}`
                ] : [
                    `${fact.label} stands here`,
                    `You are standing near ${fact.label}`,
                    `This is the site of ${fact.label}`
                ],
                'event': [
                    `In ${fact.date}, ${fact.label} happened right here`,
                    `${fact.label} took place nearby in ${fact.date}`,
                    `This location witnessed ${fact.label} in ${fact.date}`
                ],
                'headquarters': fact.ended ? [
                    `Before ${fact.ended}, ${fact.label} was headquartered nearby`,
                    `The headquarters of ${fact.label} used to be near here`,
                    `${fact.label} operated from this area until ${fact.ended}`
                ] : [
                    `${fact.label} is headquartered nearby`,
                    `The headquarters of ${fact.label} can be found here`,
                    `${fact.label} operates from this area`
                ],
                'filming': [
                    `Scenes from ${fact.label} were filmed near here`,
                    `${fact.label} used this location as a backdrop`,
                    `A film crew for ${fact.label} was once here`
                ],
                'fiction': [
                    `The story of ${fact.label} is set in this area`,
                    `This location features in the plot of ${fact.label}`,
                    `${fact.label} takes place nearby`
                ],
                'formation': fact.date ? [
                    `${fact.label} was formed nearby in ${fact.date}`,
                    `The group ${fact.label} started their journey near here`,
                    `In ${fact.date}, ${fact.label} was founded close by`
                ] : [
                    `${fact.label} was formed nearby`,
                    `The group ${fact.label} started their journey near here`,
                    `${fact.label} was founded close by`
                ]
            };

            // Generic fallback
            if (!templates[fact.type]) {
                return `${fact.label} is nearby`;
            }

            const options = templates[fact.type];
            let text = options[Math.floor(Math.random() * options.length)];

            // Append description sometimes
            if (Math.random() > 0.5 && fact.desc) {
                text += ` (${fact.desc})`;
            }
            text += ".";

            return text;
        }
    }

    new AmbientChatter();
</script>

</body>
</html>
